

## 1. useRef: За пределами рендеринга

**Концепция:** Представь, что у компонента есть "карман", куда он может положить вещь, и она не потеряется при переодевании (ререндере), но и само наличие вещи в кармане не заставляет его переодеваться.

- **Две главные роли:**
    
    1. **Доступ к DOM:** Прямое манипулирование узлами (фокус, скролл, замер размеров).
        
    2. **Хранение мутабельного значения:** Сохранение данных между рендерами, которые _не должны_ вызывать новый рендер (таймеры, ID интервалов, предыдущие значения пропсов).
        
- **Важное правило:** Изменение `ref.current` — это синхронная операция, она не ставит рендер в очередь.
    

## 2. useMemo: Кэширование результата

**Концепция:** "Запомни ответ задачи, чтобы не решать её снова, пока не изменятся условия".

- **Зачем:** Для тяжелых вычислений (фильтрация больших массивов, сложные математические операции).
    
- **Как работает:** Принимает функцию и массив зависимостей. Если зависимости не изменились, React возвращает результат из прошлой итерации.
    
- **Подвох:** Не используй его везде. Память под кэш тоже стоит ресурсов.
    

## 3. useCallback: Кэширование функции

**Концепция:** В JS функции — это объекты. Каждый раз, когда компонент рендерится, функция внутри него создается _заново_ (новая ссылка в памяти). `useCallback` сохраняет одну и ту же ссылку на функцию.

- **Главный кейс:** Передача колбэка в дочерний компонент, который обернут в `React.memo`. Если ссылка на функцию изменится, `memo` посчитает, что пропсы изменились, и перерисует "дочку".
    

---

# Практика: "Оптимизация списка задач"

Давай разберем кейс, где мы исправим лагающее приложение.

### Задача 1: useRef (Фокус при загрузке)

**Задание:** Сделай так, чтобы при открытии страницы фокус автоматически ставился в поле ввода.

JavaScript

```
import { useEffect, useRef } from 'react';

function TaskInput() {
  const inputRef = useRef(null);

  useEffect(() => {
    // Твой код: установи фокус в inputRef.current
    inputRef.current.focus();
  }, []);

  return <input ref={inputRef} type="text" placeholder="Новая задача..." />;
}
```

### Задача 2: useMemo (Фильтрация списка)

**Задание:** У нас есть список из 5000 задач. Мы хотим фильтровать их по тексту, не пересчитывая список при каждом клике по кнопке "Лайк".

JavaScript

```
const filteredTasks = useMemo(() => {
  console.log('Фильтрация...'); // Должна срабатывать только при изменении query или tasks
  return tasks.filter(t => t.text.includes(query));
}, [tasks, query]);
```

### Задача 3: useCallback + React.memo

**Задание:** Есть список задач. Каждая задача — это компонент `TaskItem`. Нужно сделать так, чтобы при удалении одной задачи остальные компоненты списка не перерендеривались.

JavaScript

```
// Дочерний компонент (уже обернут в memo)
const TaskItem = React.memo(({ task, onDelete }) => {
  console.log(`Рендер задачи: ${task.id}`);
  return <div onClick={() => onDelete(task.id)}>{task.text}</div>;
});

// Родитель
function App() {
  const [tasks, setTasks] = useState([...]);

  // Задание: Оберни handleDelete в useCallback, чтобы ссылка не менялась
  const handleDelete = useCallback((id) => {
    setTasks(prev => prev.filter(t => t.id !== id));
  }, []); // Пустой массив, если setTasks не зависит от внешних переменных

  return (
    <div>
      {tasks.map(t => <TaskItem key={t.id} task={t} onDelete={handleDelete} />)}
    </div>
  );
}
```



- **Без useCallback:** Вы каждый день пишете инструкцию на новом листе бумаги. Ученик видит новый лист и каждый раз заново его внимательно изучает, даже если текст там один и тот же.
    
- **С useCallback:** Вы один раз написали инструкцию на пластиковой карточке. Каждый день вы просто показываете ту же самую карточку. Ученик видит, что карточка та же самая, и не тратит время на её перечитывание.

JavaScript

```
import React, { useState, useCallback } from 'react';

// Представим, что это очень "тяжелый" компонент
const HeavyComponent = React.memo(({ action }) => {
  console.log("Дочерний компонент перерисовался!");
  return <button onClick={action}>Нажми на меня</button>;
});

function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  // Мы "запоминаем" функцию. 
  // Она пересоздастся ТОЛЬКО если изменится count.
  const increment = useCallback(() => {
    setCount(prev => prev + 1);
  }, [count]); 

  return (
    <div>
      <h1>Счетчик: {count}</h1>
      
      {/* Когда мы печатаем тут, меняется text. 
          App перерисовывается, но increment остается прежним!
          Благодаря React.memo и useCallback, HeavyComponent НЕ будет перерисовываться. */}
      <input value={text} onChange={(e) => setText(e.target.value)} placeholder="Печатай тут..." />
      
      <HeavyComponent action={increment} />
    </div>
  );
}
```

### Главное правило:

Используйте `useCallback` только тогда, когда вы передаете функцию в компоненты, обернутые в `React.memo`. Если вы используете её для обычной кнопки `<button>`, вы только усложняете код без какой-либо выгоды.

Хотите, я разберу подробнее, что такое массив зависимостей (те самые квадратные скобки `[]`) в этом хуке?

---

### небольшая шпаргалка:

- **Нужен доступ к DOM?** — `useRef`.
    
- **Нужно сохранить данные без рендера?** — `useRef`.
    
- **Тяжелые вычисления?** — `useMemo`.
    
- **Передаешь функцию в мемоизированный дочерний компонент?** — `useCallback`.



## Задание 1: Оптимизация тяжелых вычислений (`useMemo`)

**Контекст:** Представьте, что у вас есть список из 5,000 товаров. Вам нужно фильтровать их по названию. Фильтрация — операция ресурсозатратная, и мы не хотим, чтобы она запускалась каждый раз, когда пользователь, например, переключает "Тёмную тему" приложения.

**Ваша задача:**

1. Создайте массив из 5,000 объектов (например, `{ id: n, name: 'Item n' }`).
    
2. Добавьте текстовый инпут для поиска и кнопку переключения темы (просто меняет стейт `isDark`).
    
3. Реализуйте фильтрацию так, чтобы она вызывалась **только** при изменении текста в инпуте или исходного массива, но **не** при переключении темы.
    
4. Добавьте `console.log('Filtering...')` внутри функции фильтрации, чтобы убедиться, что она не срабатывает лишний раз.
    

---

## Задание 2: Секундомер с доступом к DOM (`useRef`)

**Контекст:** В этом задании нам нужно объединить две функции `useRef`: хранение идентификатора таймера (чтобы он не сбрасывался при ререндере) и управление фокусом.

**Ваша задача:**

1. **Работа с DOM:** Создайте страницу с инпутом и кнопкой "Старт". При нажатии на "Старт" фокус должен автоматически устанавливаться в инпут (используйте `useRef` для доступа к элементу).
    
2. **Хранение данных:** Реализуйте секундомер (вывод секунд на экран).
    
    - Используйте `useRef` для хранения `timerId` (результат функции `setInterval`).
        
    - При нажатии "Старт" запускается счетчик.
        
    - При нажатии "Стоп" нужно остановить таймер, используя сохраненный в `ref` айдишник.
        
3. **Условие:** Не используйте `useState` для хранения `timerId`, так как изменение ID таймера не должно вызывать перерисовку компонента.
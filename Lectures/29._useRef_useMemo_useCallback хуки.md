

## 1. useRef: За пределами рендеринга

**Концепция:** Представь, что у компонента есть "карман", куда он может положить вещь, и она не потеряется при переодевании (ререндере), но и само наличие вещи в кармане не заставляет его переодеваться.

- **Две главные роли:**
    
    1. **Доступ к DOM:** Прямое манипулирование узлами (фокус, скролл, замер размеров).
        
    2. **Хранение мутабельного значения:** Сохранение данных между рендерами, которые _не должны_ вызывать новый рендер (таймеры, ID интервалов, предыдущие значения пропсов).
        
- **Важное правило:** Изменение `ref.current` — это синхронная операция, она не ставит рендер в очередь.
    

## 2. useMemo: Кэширование результата

**Концепция:** "Запомни ответ задачи, чтобы не решать её снова, пока не изменятся условия".

- **Зачем:** Для тяжелых вычислений (фильтрация больших массивов, сложные математические операции).
    
- **Как работает:** Принимает функцию и массив зависимостей. Если зависимости не изменились, React возвращает результат из прошлой итерации.
    
- **Подвох:** Не используй его везде. Память под кэш тоже стоит ресурсов.
    

## 3. useCallback: Кэширование функции

**Концепция:** В JS функции — это объекты. Каждый раз, когда компонент рендерится, функция внутри него создается _заново_ (новая ссылка в памяти). `useCallback` сохраняет одну и ту же ссылку на функцию.

- **Главный кейс:** Передача колбэка в дочерний компонент, который обернут в `React.memo`. Если ссылка на функцию изменится, `memo` посчитает, что пропсы изменились, и перерисует "дочку".
    

---

# Практика: "Оптимизация списка задач"

Давай разберем кейс, где мы исправим лагающее приложение.

### Задача 1: useRef (Фокус при загрузке)

**Задание:** Сделай так, чтобы при открытии страницы фокус автоматически ставился в поле ввода.

JavaScript

```
import { useEffect, useRef } from 'react';

function TaskInput() {
  const inputRef = useRef(null);

  useEffect(() => {
    // Твой код: установи фокус в inputRef.current
    inputRef.current.focus();
  }, []);

  return <input ref={inputRef} type="text" placeholder="Новая задача..." />;
}
```

### Задача 2: useMemo (Фильтрация списка)

**Задание:** У нас есть список из 5000 задач. Мы хотим фильтровать их по тексту, не пересчитывая список при каждом клике по кнопке "Лайк".

JavaScript

```
const filteredTasks = useMemo(() => {
  console.log('Фильтрация...'); // Должна срабатывать только при изменении query или tasks
  return tasks.filter(t => t.text.includes(query));
}, [tasks, query]);
```

### Задача 3: useCallback + React.memo

**Задание:** Есть список задач. Каждая задача — это компонент `TaskItem`. Нужно сделать так, чтобы при удалении одной задачи остальные компоненты списка не перерендеривались.

JavaScript

```
// Дочерний компонент (уже обернут в memo)
const TaskItem = React.memo(({ task, onDelete }) => {
  console.log(`Рендер задачи: ${task.id}`);
  return <div onClick={() => onDelete(task.id)}>{task.text}</div>;
});

// Родитель
function App() {
  const [tasks, setTasks] = useState([...]);

  // Задание: Оберни handleDelete в useCallback, чтобы ссылка не менялась
  const handleDelete = useCallback((id) => {
    setTasks(prev => prev.filter(t => t.id !== id));
  }, []); // Пустой массив, если setTasks не зависит от внешних переменных

  return (
    <div>
      {tasks.map(t => <TaskItem key={t.id} task={t} onDelete={handleDelete} />)}
    </div>
  );
}
```

---

### небольшая шпаргалка:

- **Нужен доступ к DOM?** — `useRef`.
    
- **Нужно сохранить данные без рендера?** — `useRef`.
    
- **Тяжелые вычисления?** — `useMemo`.
    
- **Передаешь функцию в мемоизированный дочерний компонент?** — `useCallback`.
